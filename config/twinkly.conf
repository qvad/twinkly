# Dual-Proxy Configuration
# This configuration manages differences between PostgreSQL and YugabyteDB

proxy {
  # Proxy server settings
  listen-port = 5431
  
  # Backend database connections
  postgresql {
    host = "localhost"
    port = 5432
    user = "postgres"
    database = "postgres"
    # Connection pool settings
    max-connections = 100
    connection-timeout = 30s
  }
  
  yugabytedb {
    host = "localhost" 
    port = 5433
    user = "postgres"
    database = "postgres"
    # Connection pool settings
    max-connections = 100
    connection-timeout = 30s
  }
  
  # Query routing rules
  routing {
    # Route these query patterns to PostgreSQL only
    postgres-only-patterns = [
      "pg_.*",
      "information_schema.*",
      "SELECT.*current_setting",
      "SHOW.*",
      ".*version\\(\\).*"
    ]
    
    # Route these to YugabyteDB only
    yugabyte-only-patterns = [
    ]
    
    # Default routing (when no pattern matches)
    default-target = "dual"  # Options: "postgresql", "yugabytedb", "dual"
  }
}

# Result comparison settings (for testing environments)
comparison {
    # Enable dual-database execution for result comparison
    # If true, queries will be rejected when the secondary backend is unavailable (STRICT default).
    # If false, Twinkly operates in degraded mode: routes only to source-of-truth and disables comparisons for the connection.
    require-secondary = true
    enabled = true
    
    # YugabyteDB is the source of truth (CRITICAL: returns YB results to user)
    source-of-truth = "yugabytedb"
    
    # Force ORDER BY on queries for consistent comparison (rewrites queries)
    force-order-by-compare = false

    # Alternatively, sort result sets in-memory before comparing (does not rewrite queries)
    sort-before-compare = true
    
    # Columns to use for forced ordering (when no ORDER BY present)
    default-order-columns = ["id", "pk", "primary_key", "*"]
    
    # Maximum rows to compare (for performance)
    max-compare-rows = 1000
    
    # Log comparison results
    log-comparisons = true
    
    # Log only differences (not matches)
    log-differences-only = false
    
    # CRITICAL FEATURE 1: Fail on differences (return SQL error to user)
    fail-on-differences = true

    # CRITICAL FEATURE 2: Slow query analysis with EXPLAIN ANALYZE
    report-slow-queries = true
    slow-query-ratio = 4.0        # Fail if YB is 4x slower than PG
    fail-on-slow-queries = true   # Return error with EXPLAIN ANALYZE plans

    # ============================================================
    # REPORTING OPTIONS - All explicit so you can see what's ON/OFF
    # ============================================================

    # Row count mismatch reporting (different number of rows)
    report-row-count-mismatch = true

    # Data value mismatch reporting (same row count but different data)
    report-data-value-mismatch = true

    # Error divergence reporting (one DB succeeds while other fails)
    # WARNING: Currently unstable - may incorrectly report false positives
    report-error-divergence = false

    # Syntax error divergence behavior
    syntax-error-divergence-fail-and-rollback = true   # abort client flow with error
    syntax-error-divergence-report = false             # do not create report files

    # EXPLAIN tuning
    explain {
      # Used for SELECT/WITH queries
      select = "EXPLAIN (ANALYZE)"
      # Used for non-SELECT statements (UPDATE/DELETE/INSERT, etc.)
      other  = "EXPLAIN"
    }

    # AI Analysis settings (Experimental)
    # Disabled by default. Used to analyze performance discrepancies using LLMs.
    ai {
      enabled = false
      provider = "mock" # Options: "mock", "gemini", "openai"
      api-key = ""
      endpoint = ""
      model = "gemini-2.5-pro"
    }
    
    # Queries to exclude from comparison
    exclude-patterns = [
      "SHOW.*",
      "SELECT.*version\\(\\).*",
      "SELECT.*current_timestamp.*",
      "SELECT.*now\\(\\).*"
    ]
}

# Feature compatibility mappings
features {
  # Features supported differently between databases
  
  # Transaction isolation levels
  isolation-levels {
    postgresql = ["READ UNCOMMITTED", "READ COMMITTED", "REPEATABLE READ", "SERIALIZABLE"]
    yugabytedb = ["READ COMMITTED", "REPEATABLE READ", "SERIALIZABLE"]
    
    # Mapping when YB doesn't support PG isolation level
    mapping {
      "READ UNCOMMITTED" = "READ COMMITTED"
    }
  }
  
  # Index types
  index-types {
    postgresql = ["btree", "hash", "gist", "spgist", "gin", "brin"]
    yugabytedb = ["btree", "hash", "gin"]
    
    # What to do when index type not supported
    unsupported-action = "convert-to-btree"  # or "error"
  }
  
  # SQL features
  sql-features {
    # Features that need special handling
    advisory-locks {
      postgresql = true
      yugabytedb = false
      on-unsupported = "ignore"  # Options: "ignore", "error", "emulate"
    }
    
    listen-notify {
      postgresql = true
      yugabytedb = false
      on-unsupported = "error"
    }
    
    large-objects {
      postgresql = true
      yugabytedb = false
      on-unsupported = "error"
    }
  }
}

# Error mapping configuration
error-mappings {
  # Transaction-related errors
  transaction-errors {
    # PostgreSQL transaction errors that map to YugabyteDB equivalents
    deadlock {
      postgresql-codes = ["40P01"] # deadlock_detected
      yugabytedb-codes = ["40001"] # serialization_failure
      
      # How to handle the mapping
      action = "retry"  # Options: "retry", "pass-through", "transform"
      max-retries = 3
      retry-delay = 100ms
    }
    
    serialization-failure {
      postgresql-codes = ["40001"] # serialization_failure
      yugabytedb-codes = ["40001"] # serialization_failure
      action = "pass-through"
    }
    
    lock-timeout {
      postgresql-codes = ["55P03"] # lock_not_available
      yugabytedb-codes = ["55P03", "40001"] # YB might return serialization_failure
      action = "transform"
      transform-message = "Lock timeout - transaction aborted"
    }
  }
  
  # Constraint violation errors
  constraint-errors {
    unique-violation {
      postgresql-codes = ["23505"] # unique_violation
      yugabytedb-codes = ["23505"]
      action = "pass-through"
    }
    
    foreign-key-violation {
      postgresql-codes = ["23503"] # foreign_key_violation
      yugabytedb-codes = ["23503"]
      action = "pass-through"
    }
    
    check-violation {
      postgresql-codes = ["23514"] # check_violation
      yugabytedb-codes = ["23514"]
      action = "pass-through"
    }
  }
  
  # Feature-related errors
  feature-errors {
    feature-not-supported {
      postgresql-codes = ["0A000"] # feature_not_supported
      yugabytedb-codes = ["0A000", "XX000"] # YB might use internal_error
      
      # Custom handling for specific features
      custom-handlers = {
        "advisory locks" = {
          action = "transform"
          transform-code = "0A000"
          transform-message = "Advisory locks not supported in YugabyteDB"
        }
        
        "listen/notify" = {
          action = "transform"
          transform-code = "0A000"
          transform-message = "LISTEN/NOTIFY not supported in YugabyteDB"
        }
      }
    }
  }
  
  # Connection errors
  connection-errors {
    connection-failure {
      postgresql-codes = ["08000", "08003", "08006"]
      yugabytedb-codes = ["08000", "08003", "08006", "XX000"]
      action = "retry"
      max-retries = 3
      retry-delay = 1s
    }
    
    admin-shutdown {
      postgresql-codes = ["57P01"] # admin_shutdown
      yugabytedb-codes = ["57P01", "XX000"]
      action = "reconnect"
    }
  }
  
  # Data errors
  data-errors {
    division-by-zero {
      postgresql-codes = ["22012"] # division_by_zero
      yugabytedb-codes = ["22012"]
      action = "pass-through"
    }
    
    numeric-overflow {
      postgresql-codes = ["22003"] # numeric_value_out_of_range
      yugabytedb-codes = ["22003"]
      action = "pass-through"
    }
  }
}

# Query transformation rules
query-transformations {
  # Transform queries that use unsupported features
  
  advisory-locks {
    # Pattern to match advisory lock functions
    patterns = [
      "pg_advisory_lock.*",
      "pg_try_advisory_lock.*",
      "pg_advisory_unlock.*"
    ]
    
    # What to do when matched
    action = "reject"  # Options: "reject", "ignore", "transform"
    error-message = "Advisory locks are not supported in twinkly mode with YugabyteDB"
  }
  
  system-columns {
    # YugabyteDB doesn't support some system columns
    unsupported = ["tableoid", "ctid"]
    action = "remove"  # Options: "remove", "error"
  }
  
  # Add more transformation rules as needed
}

# Monitoring and logging
monitoring {
  # Log all errors
  log-errors = true
  
  # Log error mappings
  log-error-mappings = true
  
  # Log query routing decisions
  log-routing-decisions = false
  
  # Metrics collection
  metrics {
    enabled = true
    port = 9090
    
    # What to track
    track {
      query-count = true
      error-count = true
      error-mappings = true
      connection-count = true
      transaction-retries = true
    }
  }
}

# Testing and debugging
debug {
  # Enable debug logging
  enabled = true
  
  # Log all queries
  log-all-queries = true
  
  # Log protocol messages
  log-protocol = true

  # Dump every byte the proxy SENDS (hex). Extremely verbose; use for protocol debugging
  dump-network = false

  # Simulate errors for testing
  simulate-errors {
    enabled = false
    error-rate = 0.01  # 1% of queries
    error-types = ["deadlock", "serialization-failure"]
  }
}